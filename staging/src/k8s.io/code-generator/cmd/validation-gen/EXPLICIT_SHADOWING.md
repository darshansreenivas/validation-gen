# Declarative Validation Native (DV Native)

"Declarative Validation Native" (DV Native) is a mode of operation for the declarative validation framework where declarative tags serve as the **authoritative** source of truth for API validation. In this mode, validation logic is defined exclusively using Go comment tags, without requiring a parallel hand-written implementation in Go or relying on global feature gates.

Starting in v1.36, this mode is enabled via a resource-level strategy configuration called **Explicit Shadowing**.

## The Concept: Explicit Shadowing

In previous versions, Declarative Validation (DV) ran in a global "Implicit Shadow" mode: tags were checked, but errors were suppressed (shadowed) by default to prevent conflicts with legacy handwritten code.

With the new **Explicit Shadowing** strategy, we invert this relationship for specific resources:
1.  **Authoritative by Default:** Standard validation tags (e.g., `+k8s:minimum`) become authoritative and are enforced immediately.
2.  **Shadow Opt-Out:** If a specific validation rule is not yet ready for enforcement (e.g., during migration of legacy fields or testing new rules), it is explicitly marked with `+k8s:shadow`.

## Enabling Native Mode (The Strategy)

To enable authoritative declarative validation (Native Mode) for your API, you must update the `strategy.go` file for your resource.

Replace the standard declarative validation call with one including the `rest.WithExplicitShadowing()` option:

```go
func (myStrategy) Validate(ctx context.Context, obj runtime.Object) field.ErrorList {
    myObj := obj.(*myapi.MyResource)
    allErrs := validation.ValidateMyResource(myObj)
    
    // The WithExplicitShadowing() option makes standard tags authoritative (Native)
    // and bypasses the global feature gate checks.
    return rest.ValidateDeclarativelyWithMigrationChecks(
        ctx, 
        legacyscheme.Scheme, 
        obj, 
        nil, 
        allErrs, 
        operation.Create, 
        rest.WithExplicitShadowing(), 
    )
}
```

**Note:** For new APIs (v1.36+), this is the recommended configuration.

## The `+k8s:shadow` Tag Prefix

When `WithExplicitShadowing()` is enabled, all standard tags are enforced. If you need to add a validation tag but **suppress** its enforcement (e.g., to test it against existing data without rejecting requests), use the shadow prefix.

- **Syntax**: `+k8s:shadow(introducedVersion=<version>)=+k8s:<tag>=<value>`
- **Behavior**: The generator produces code that executes the validation but suppresses the error from the API response. Mismatches are recorded in metrics (`declarative_validation_mismatch_total`).

### Example: Hybrid Validation

In this example, `BurstLimit` is enforced authoritatively (Native), while `LegacyField` is being tested in shadow mode.

```go
type NewFeatureSpec struct {
    // This is Authoritative (Native) because WithExplicitShadowing is on.
    // Requests failing this validation will be rejected.
    // +k8s:required
    // +k8s:minimum=1
    BurstLimit int32 `json:"burstLimit"`

    // This is Shadowed. It runs, metrics are emitted on failure, 
    // but the request is NOT rejected.
    // +k8s:shadow(introducedVersion=v1.36)=+k8s:maxLength=10
    LegacyField string `json:"legacyField"`
}
```

## Stability Levels & Constraints

When using `WithExplicitShadowing()` (Native Mode), strict stability rules apply to ensure API reliability:

1.  **Standard Tags MUST be Stable:** You cannot use Alpha or Beta tags as authoritative validations.
    *   *Allowed:* `+k8s:minimum`, `+k8s:enum`, `+k8s:required`, `+k8s:format` (Stable).
    *   *Blocked:* `+k8s:cel` (if Beta/Alpha).
2.  **Shadow Tags can be Unstable:** You generally use the `+k8s:shadow` prefix to test Alpha/Beta validation logic or to safely migrate legacy logic.

## Wiring Up Declarative Validation
If the Kubernetes API object is not currently plumbed for declarative validation, additional plumbing will need to be done first before adding the DV Native validation. You can check if the plumbing is done by checking if there are any other current DV tags in the `types.go` file or by looking at the associated `doc.go` file and `strategy.go` file for the type. See [MIGRATION_GUIDE.md](MIGRATION_GUIDE.md) for more information.

## Testing DV Native

When `WithExplicitShadowing()` is enabled, errors generated by standard tags are marked programmatically as "DeclarativeNative". Your tests must account for this to ensure the validation is correctly identified as authoritative.

### Marking Expected Errors

In your test cases, use `.MarkDeclarativeNative()` on the expected errors for fields that are not shadowed.

```go
{
    name: "missing native field",
    obj: &MyResource{...},
    expectedErrs: field.ErrorList{
        // Because the field uses standard tags in an Explicit Shadowing strategy,
        // the error is marked as Native.
        field.Required(field.NewPath("spec", "myNativeField"), "").MarkDeclarativeNative(),
    },
}
```

## Walkthrough: New API validation DV Native usage

This walkthrough demonstrates how to use DV Native for a new field, using the `Workload` API as an example.

### 1. Update API Types

Add the standard validation tags to your field in `types.go`. **Do not** add a `+k8s:declarativeValidationNative` tag (it is no longer used).

```go
type PodGroup struct {
    // Name is a unique identifier for the PodGroup within the Workload.
    // +required
    // +k8s:required
    // +k8s:format=k8s-short-name
    Name string `json:"name" protobuf:"bytes,1,opt,name=name"`
    ...
}
```

### 2. Update the Strategy

Ensure your strategy calls the declarative validation with the `rest.WithExplicitShadowing()` option.

```go
func (workloadStrategy) Validate(ctx context.Context, obj runtime.Object) field.ErrorList {
    workloadScheduling := obj.(*scheduling.Workload)
    allErrs := validation.ValidateWorkload(workloadScheduling)
    
    // Enable Explicit Shadowing to make the tags authoritative
    return rest.ValidateDeclarativelyWithMigrationChecks(
        ctx, 
        legacyscheme.Scheme, 
        obj, 
        nil, 
        allErrs, 
        operation.Create, 
        rest.WithExplicitShadowing(),
    )
}
```

### 3. Write Associated Tests

When writing tests for your validation logic, any expected errors being matched will need to be marked as native.

```go
"no pod group name": {
    obj: mkWorkload(func(w *scheduling.Workload) {
        w.Spec.PodGroups[0].Name = ""
    }),
    expectedErrs: field.ErrorList{
        field.Required(field.NewPath("spec", "podGroups").Index(0).Child("name"), "").MarkDeclarativeNative(),
    },
},
```

### 4. Regenerate and Verify

Run the code generator and your tests:

```bash
hack/update-codegen.sh validation
go test ./pkg/registry/<group>/<kind>/...
```